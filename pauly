#!/usr/bin/env bash

# Pauly CLI
# Manage your automated AI assistant scripts

set -e

# Resolve symlinks to get the real script directory
SCRIPT_PATH="$0"
if [ -L "$SCRIPT_PATH" ]; then
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
source "$SCRIPT_DIR/lib/config.sh" 2>/dev/null || true
source "$SCRIPT_DIR/lib/common.sh" 2>/dev/null || true
source "$SCRIPT_DIR/lib/dev.sh" 2>/dev/null || true
source "$SCRIPT_DIR/lib/autofix.sh" 2>/dev/null || true
source "$SCRIPT_DIR/lib/railway.sh" 2>/dev/null || true
source "$SCRIPT_DIR/lib/queue.sh" 2>/dev/null || true

VERSION="1.0.0"
CRON_MARKER="# pauly-job"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color
BOLD='\033[1m'

# ==========================================
# Helper Functions
# ==========================================

print_header() {
    echo -e "${BOLD}${BLUE}Pauly${NC} v${VERSION}"
    echo ""
}

print_success() {
    echo -e "${GREEN}✓${NC} $1"
}

print_error() {
    echo -e "${RED}✗${NC} $1" >&2
}

print_warning() {
    echo -e "${YELLOW}!${NC} $1"
}

print_info() {
    echo -e "${CYAN}→${NC} $1"
}

# ==========================================
# Commands
# ==========================================

cmd_help() {
    print_header
    echo "Usage: pauly <command> [options]"
    echo ""
    echo "Commands:"
    echo -e "  ${BOLD}run${NC} <job> [-bg]  Run a job manually (summary, git, research, all)"
    echo -e "  ${BOLD}dev${NC} [opts]       Autonomous development mode"
    echo -e "  ${BOLD}admin${NC} [cmd]      Manage admin dashboard (start/stop/status)"
    echo -e "  ${BOLD}tui${NC}              Interactive terminal dashboard"
    echo -e "  ${BOLD}railway${NC} [cmd]    Railway deployment commands"
    echo -e "  ${BOLD}status${NC}           Show status of all scheduled jobs"
    echo -e "  ${BOLD}logs${NC} [-f] [job]  View logs (-f to follow in real-time)"
    echo -e "  ${BOLD}tail${NC} [job]       Follow logs in real-time"
    echo -e "  ${BOLD}enable${NC} <job>     Enable a scheduled job"
    echo -e "  ${BOLD}disable${NC} <job>    Disable a scheduled job"
    echo -e "  ${BOLD}test-email${NC}       Send a test email"
    echo -e "  ${BOLD}setup${NC}            Run the Mac Mini setup script"
    echo -e "  ${BOLD}install${NC}          Install all npm dependencies"
    echo -e "  ${BOLD}config${NC}           Configure settings interactively"
    echo -e "  ${BOLD}config show${NC}      Show current configuration"
    echo -e "  ${BOLD}doctor${NC}           Run system health checks"
    echo -e "  ${BOLD}completions${NC}      Show shell completion setup instructions"
    echo -e "  ${BOLD}autofix${NC}          Show auto-fix status"
    echo -e "  ${BOLD}autofix test${NC}     Test auto-fix with simulated failure"
    echo -e "  ${BOLD}autofix logs${NC}     View auto-fix logs"
    echo -e "  ${BOLD}queue${NC}            Show task queue status"
    echo -e "  ${BOLD}queue list${NC}       List jobs in queue"
    echo -e "  ${BOLD}queue cleanup${NC}    Cleanup stale and old jobs"
    echo -e "  ${BOLD}kill${NC}             Stop all running Claude/dev processes"
    echo -e "  ${BOLD}version${NC}          Show version (--check to check for updates)"
    echo -e "  ${BOLD}help${NC}             Show this help message"
    echo ""
    echo "Jobs:"
    echo "  summary    Daily Claude activity summary (5am)"
    echo "  git        Git repository health check (6am)"
    echo "  research   Project competitive analysis (Mondays 7am)"
    echo "  tasks      Check for tasks (GitHub Issues and/or email)"
    echo "  all        Run all jobs sequentially"
    echo ""
    echo "Dev Commands:"
    echo "  pauly dev [n]                        Run n iterations of PLAN->EXECUTE->REVIEW->FIX"
    echo "  pauly dev init <idea.md>             Bootstrap project from idea file"
    echo "  pauly dev init --template <name>     Bootstrap from template"
    echo "  pauly dev init --template list       List available templates"
    echo "  pauly dev refresh <notes>            Add tasks from freeform notes"
    echo "  pauly dev task \"desc\"                Run isolated single-task mode"
    echo "  pauly dev status                     Show development progress"
    echo ""
    echo "Dev Options:"
    echo "  -n <num>                   Max iterations (default 25)"
    echo "  --dry-run                  Preview what would happen without executing"
    echo "  --template, -t <name>      Use project template (init mode)"
    echo "  --branch <name>            Use custom branch name (task mode)"
    echo "  --no-pr                    Skip PR creation (task mode)"
    echo "  -f, --file <file>          Read task from file (task mode)"
    echo ""
    echo "Templates:"
    echo "  react-vite    React 19 + Vite + Tailwind + shadcn/ui"
    echo "  express-api   Express.js REST API with TypeScript"
    echo "  fullstack     React frontend + Express backend"
    echo "  cli-tool      CLI with Commander.js and TypeScript"
    echo ""
    echo "Options:"
    echo "  -bg, --background    Run in background (persists after SSH disconnect)"
    echo ""
    echo "Examples:"
    echo "  pauly run summary          # Run daily summary now"
    echo "  pauly run all -bg          # Run all jobs in background"
    echo "  pauly dev init idea.md     # Start new project from idea"
    echo "  pauly dev 10               # Run 10 dev iterations"
    echo "  pauly dev task \"fix bug\"   # Work on isolated task"
}

cmd_version() {
    local check_update="$1"

    echo "pauly v${VERSION}"

    if [ "$check_update" = "--check" ] || [ "$check_update" = "-c" ]; then
        echo ""
        print_info "Checking for updates..."

        # Check if gh CLI is available
        if ! command -v gh &> /dev/null; then
            print_warning "GitHub CLI (gh) not installed. Cannot check for updates."
            echo "Install with: brew install gh"
            return 1
        fi

        # Fetch latest release from GitHub
        local latest_version
        latest_version=$(gh api repos/tony-garand/pauly/releases/latest --jq '.tag_name' 2>/dev/null | sed 's/^v//')

        if [ -z "$latest_version" ]; then
            # Try checking tags if no releases
            latest_version=$(gh api repos/tony-garand/pauly/tags --jq '.[0].name' 2>/dev/null | sed 's/^v//')
        fi

        if [ -z "$latest_version" ]; then
            print_warning "Could not fetch latest version from GitHub."
            return 1
        fi

        # Compare versions
        if [ "$VERSION" = "$latest_version" ]; then
            print_success "You're running the latest version!"
        else
            echo ""
            print_warning "Update available: v${VERSION} → v${latest_version}"
            echo ""
            echo "To update, run:"
            echo "  cd ~/.pauly && git pull"
        fi
    fi
}

cmd_status() {
    print_header
    echo -e "${BOLD}Scheduled Jobs:${NC}"
    echo ""

    local current_cron=$(crontab -l 2>/dev/null || echo "")

    # Check each job
    if echo "$current_cron" | grep -q "$CRON_MARKER:summary"; then
        echo -e "  ${GREEN}●${NC} ${BOLD}summary${NC}  - 5:00am daily"
    else
        echo -e "  ${RED}○${NC} ${BOLD}summary${NC}  - 5:00am daily (disabled)"
    fi

    if echo "$current_cron" | grep -q "$CRON_MARKER:git"; then
        echo -e "  ${GREEN}●${NC} ${BOLD}git${NC}      - 6:00am daily"
    else
        echo -e "  ${RED}○${NC} ${BOLD}git${NC}      - 6:00am daily (disabled)"
    fi

    if echo "$current_cron" | grep -q "$CRON_MARKER:research"; then
        echo -e "  ${GREEN}●${NC} ${BOLD}research${NC} - 7:00am Mondays"
    else
        echo -e "  ${RED}○${NC} ${BOLD}research${NC} - 7:00am Mondays (disabled)"
    fi

    if echo "$current_cron" | grep -q "$CRON_MARKER:tasks"; then
        echo -e "  ${GREEN}●${NC} ${BOLD}tasks${NC}    - every 5 minutes"
    else
        echo -e "  ${RED}○${NC} ${BOLD}tasks${NC}    - every 5 minutes (disabled)"
    fi

    if echo "$current_cron" | grep -q "$CRON_MARKER:dev"; then
        echo -e "  ${GREEN}●${NC} ${BOLD}dev${NC}      - every 5 minutes (ensure dev running)"
    else
        echo -e "  ${RED}○${NC} ${BOLD}dev${NC}      - every 5 minutes (disabled)"
    fi

    echo ""
    echo -e "${BOLD}Recent Activity:${NC}"
    echo ""

    # Show last run time for each job
    for log_name in daily-summary git-health-check project-research github-tasks email-tasks; do
        local log_file="$SCRIPT_DIR/logs/${log_name}.log"
        if [ -f "$log_file" ]; then
            local last_run=$(grep -E "^\[" "$log_file" 2>/dev/null | tail -1 | grep -oE '\[.*\]' | tr -d '[]')
            if [ -n "$last_run" ]; then
                echo "  ${log_name}: last run $last_run"
            fi
        fi
    done

    echo ""
    echo -e "${BOLD}Configuration:${NC}"
    if config_exists; then
        echo "  Email:    ${EMAIL:-<not set>}"
        echo "  Projects: ${PROJECTS_DIR:-$HOME/Projects}"
        if [ -n "$HEALTHCHECK_URL" ]; then
            echo "  Healthcheck: configured"
        fi
    else
        print_warning "Not configured (run: pauly config)"
    fi

    echo ""
    echo -e "${BOLD}Task Systems:${NC}"
    if [ -n "$GITHUB_TASKS_REPO" ]; then
        print_success "GitHub Issues: $GITHUB_TASKS_REPO (label: $GITHUB_TASKS_LABEL)"
    else
        echo -e "  ${RED}○${NC} GitHub Issues: not configured"
    fi

    if [ -n "$ALLOWED_SENDERS" ]; then
        print_success "Email tasks: enabled"
    else
        echo -e "  ${RED}○${NC} Email tasks: not configured"
    fi

    echo ""
    echo -e "${BOLD}Email Setup:${NC}"
    if [ -f "$HOME/.msmtprc" ]; then
        if grep -q "YOUR_EMAIL\|YOUR_APP_PASSWORD" "$HOME/.msmtprc" 2>/dev/null; then
            print_warning "SMTP not configured (edit ~/.msmtprc)"
        else
            print_success "SMTP configured"
        fi
    else
        print_warning "SMTP not configured (run: pauly setup)"
    fi
}

cmd_run() {
    local job="$1"
    local background="$2"

    # Check for background flag
    if [ "$background" = "-bg" ] || [ "$background" = "--background" ]; then
        cmd_run_background "$job"
        return
    fi

    case "$job" in
        summary|daily)
            print_info "Running daily summary..."
            "$SCRIPT_DIR/daily-claude-summary.sh"
            ;;
        git|health)
            print_info "Running git health check..."
            "$SCRIPT_DIR/git-health-check.sh"
            ;;
        research|competitive)
            print_info "Running project research..."
            "$SCRIPT_DIR/project-research.sh"
            ;;
        tasks)
            # Run configured task systems
            local ran_any=false

            if [ -n "$GITHUB_TASKS_REPO" ]; then
                print_info "Checking GitHub Issues for tasks..."
                "$SCRIPT_DIR/check-github-tasks.sh"
                ran_any=true
            fi

            if [ -n "$ALLOWED_SENDERS" ]; then
                print_info "Checking email for tasks..."
                "$SCRIPT_DIR/check-email-tasks.sh"
                ran_any=true
            fi

            if [ "$ran_any" = false ]; then
                print_warning "No task systems configured."
                echo "Run 'pauly config' to set up GitHub Issues or email tasks."
            fi
            ;;
        all)
            print_info "Running all jobs..."
            "$SCRIPT_DIR/daily-claude-summary.sh"
            "$SCRIPT_DIR/git-health-check.sh"
            "$SCRIPT_DIR/project-research.sh"
            ;;
        -bg|--background)
            print_error "Please specify a job before -bg flag"
            echo "Example: pauly run all -bg"
            exit 1
            ;;
        "")
            print_error "Please specify a job: summary, git, research, or all"
            exit 1
            ;;
        *)
            print_error "Unknown job: $job"
            echo "Available jobs: summary, git, research, all"
            exit 1
            ;;
    esac
}

cmd_run_background() {
    local job="$1"
    local pid_file="$SCRIPT_DIR/logs/background.pid"
    local bg_log="$SCRIPT_DIR/logs/background.log"

    # Check if already running
    if [ -f "$pid_file" ]; then
        local old_pid=$(cat "$pid_file")
        if kill -0 "$old_pid" 2>/dev/null; then
            print_warning "A background job is already running (PID: $old_pid)"
            echo "View progress: pauly tail"
            echo "Or kill it: kill $old_pid"
            return 1
        fi
    fi

    local scripts=""
    case "$job" in
        summary|daily)
            scripts="$SCRIPT_DIR/daily-claude-summary.sh"
            ;;
        git|health)
            scripts="$SCRIPT_DIR/git-health-check.sh"
            ;;
        research|competitive)
            scripts="$SCRIPT_DIR/project-research.sh"
            ;;
        all)
            scripts="$SCRIPT_DIR/daily-claude-summary.sh $SCRIPT_DIR/git-health-check.sh $SCRIPT_DIR/project-research.sh"
            ;;
        *)
            print_error "Unknown job: $job"
            exit 1
            ;;
    esac

    # Run in background with nohup
    (
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Background job started: $job" >> "$bg_log"
        for script in $scripts; do
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Running: $(basename "$script")" >> "$bg_log"
            "$script" >> "$bg_log" 2>&1
        done
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Background job completed: $job" >> "$bg_log"
        rm -f "$pid_file"
    ) &

    local bg_pid=$!
    echo "$bg_pid" > "$pid_file"
    disown "$bg_pid"

    print_success "Started $job in background (PID: $bg_pid)"
    echo ""
    echo "The job will continue running after you disconnect."
    echo ""
    echo "Monitor progress:"
    echo "  pauly tail           # Follow logs live"
    echo "  pauly logs           # View recent logs"
    echo "  kill $bg_pid                # Stop the job"
}

cmd_tail() {
    local job="$1"
    local log_file=""

    case "$job" in
        summary|daily)
            log_file="$SCRIPT_DIR/logs/daily-summary.log"
            ;;
        git|health)
            log_file="$SCRIPT_DIR/logs/git-health-check.log"
            ;;
        research|competitive)
            log_file="$SCRIPT_DIR/logs/project-research.log"
            ;;
        tasks)
            print_info "Following task logs (Ctrl+C to stop)"
            tail -f "$SCRIPT_DIR/logs/github-tasks.log" "$SCRIPT_DIR/logs/email-tasks.log" 2>/dev/null
            return
            ;;
        ""|all)
            log_file="$SCRIPT_DIR/logs/background.log"
            ;;
        *)
            print_error "Unknown job: $job"
            exit 1
            ;;
    esac

    if [ -f "$log_file" ]; then
        print_info "Following $log_file (Ctrl+C to stop)"
        tail -f "$log_file"
    else
        print_warning "No logs found at $log_file"
    fi
}

cmd_logs() {
    local job=""
    local follow=false
    local lines=100

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -f|--follow)
                follow=true
                shift
                ;;
            -n)
                lines="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                echo "Usage: pauly logs [-f] [-n lines] [job]"
                exit 1
                ;;
            *)
                job="$1"
                shift
                ;;
        esac
    done

    local log_file=""

    case "$job" in
        summary|daily)
            log_file="$SCRIPT_DIR/logs/daily-summary.log"
            ;;
        git|health)
            log_file="$SCRIPT_DIR/logs/git-health-check.log"
            ;;
        research|competitive)
            log_file="$SCRIPT_DIR/logs/project-research.log"
            ;;
        tasks)
            if [ "$follow" = true ]; then
                print_info "Following task logs (Ctrl+C to stop)"
                tail -f "$SCRIPT_DIR/logs/github-tasks.log" "$SCRIPT_DIR/logs/email-tasks.log" 2>/dev/null
            else
                echo -e "${BOLD}Task Logs:${NC}"
                echo ""
                for task_log in "$SCRIPT_DIR/logs/github-tasks.log" "$SCRIPT_DIR/logs/email-tasks.log"; do
                    if [ -f "$task_log" ]; then
                        echo -e "${CYAN}=== $(basename "$task_log") ===${NC}"
                        tail -50 "$task_log"
                        echo ""
                    fi
                done
            fi
            return
            ;;
        admin)
            log_file="$SCRIPT_DIR/logs/admin.log"
            ;;
        autofix)
            log_file="$SCRIPT_DIR/logs/autofix.log"
            ;;
        dev)
            # Find most recent dev log
            log_file=$(ls -t "$SCRIPT_DIR/logs"/dev-*.log 2>/dev/null | head -1)
            if [ -z "$log_file" ]; then
                print_warning "No dev logs found"
                return
            fi
            ;;
        background|bg)
            log_file="$SCRIPT_DIR/logs/background.log"
            ;;
        "")
            if [ "$follow" = true ]; then
                # Follow all logs
                print_info "Following all logs (Ctrl+C to stop)"
                tail -f "$SCRIPT_DIR/logs"/*.log 2>/dev/null
                return
            else
                # Show all logs
                echo -e "${BOLD}All Logs:${NC}"
                echo ""
                for log in "$SCRIPT_DIR/logs"/*.log; do
                    if [ -f "$log" ]; then
                        echo -e "${CYAN}=== $(basename "$log") ===${NC}"
                        tail -20 "$log"
                        echo ""
                    fi
                done
                return
            fi
            ;;
        *)
            # Try to find a matching log file
            if [ -f "$SCRIPT_DIR/logs/${job}.log" ]; then
                log_file="$SCRIPT_DIR/logs/${job}.log"
            elif [ -f "$SCRIPT_DIR/logs/${job}-*.log" ]; then
                log_file=$(ls "$SCRIPT_DIR/logs/${job}-"*.log 2>/dev/null | head -1)
            else
                print_error "Unknown job: $job"
                echo ""
                echo "Available logs:"
                for log in "$SCRIPT_DIR/logs"/*.log; do
                    [ -f "$log" ] && echo "  $(basename "$log" .log)"
                done
                exit 1
            fi
            ;;
    esac

    if [ -n "$log_file" ]; then
        if [ -f "$log_file" ]; then
            if [ "$follow" = true ]; then
                print_info "Following $log_file (Ctrl+C to stop)"
                tail -f "$log_file"
            else
                echo -e "${BOLD}Logs: $log_file${NC}"
                echo ""
                tail -"$lines" "$log_file"
            fi
        else
            print_warning "No logs found at $log_file"
        fi
    fi
}

cmd_enable() {
    local job="$1"
    local cron_schedule=""
    local script_path=""

    case "$job" in
        summary|daily)
            job="summary"
            cron_schedule="0 5 * * *"  # 5am daily
            script_path="$SCRIPT_DIR/daily-claude-summary.sh"
            ;;
        git|health)
            job="git"
            cron_schedule="0 6 * * *"  # 6am daily
            script_path="$SCRIPT_DIR/git-health-check.sh"
            ;;
        research|competitive)
            job="research"
            cron_schedule="0 7 * * 1"  # 7am Mondays
            script_path="$SCRIPT_DIR/project-research.sh"
            ;;
        tasks)
            job="tasks"
            cron_schedule="*/5 * * * *"  # Every 5 minutes
            # Use a wrapper that runs both configured task systems
            script_path="$SCRIPT_DIR/pauly run tasks"
            ;;
        dev)
            job="dev"
            cron_schedule="*/5 * * * *"  # Every 5 minutes
            script_path="$SCRIPT_DIR/ensure-dev-running.sh"
            ;;
        all)
            cmd_enable "summary"
            cmd_enable "git"
            cmd_enable "research"
            cmd_enable "dev"
            return
            ;;
        "")
            print_error "Please specify a job: summary, git, research, dev, or all"
            exit 1
            ;;
        *)
            print_error "Unknown job: $job"
            exit 1
            ;;
    esac

    # Get current crontab
    local current_cron=$(crontab -l 2>/dev/null || echo "")

    # Check if already enabled
    if echo "$current_cron" | grep -q "$CRON_MARKER:$job"; then
        print_warning "$job is already enabled"
        return
    fi

    # Add new cron entry
    local new_entry="$cron_schedule $script_path >> $SCRIPT_DIR/logs/cron.log 2>&1 $CRON_MARKER:$job"

    if [ -z "$current_cron" ]; then
        echo "$new_entry" | crontab -
    else
        (echo "$current_cron"; echo "$new_entry") | crontab -
    fi

    print_success "Enabled $job ($cron_schedule)"
}

cmd_disable() {
    local job="$1"

    case "$job" in
        summary|daily)
            job="summary"
            ;;
        git|health)
            job="git"
            ;;
        research|competitive)
            job="research"
            ;;
        tasks|email)
            job="tasks"
            ;;
        dev)
            job="dev"
            ;;
        all)
            cmd_disable "summary"
            cmd_disable "git"
            cmd_disable "research"
            cmd_disable "tasks"
            cmd_disable "dev"
            return
            ;;
        "")
            print_error "Please specify a job: summary, git, research, tasks, dev, or all"
            exit 1
            ;;
        *)
            print_error "Unknown job: $job"
            exit 1
            ;;
    esac

    # Get current crontab
    local current_cron=$(crontab -l 2>/dev/null || echo "")

    # Check if enabled
    if ! echo "$current_cron" | grep -q "$CRON_MARKER:$job"; then
        print_warning "$job is not enabled"
        return
    fi

    # Remove the job
    echo "$current_cron" | grep -v "$CRON_MARKER:$job" | crontab -

    print_success "Disabled $job"
}

cmd_test_email() {
    if [ -z "$EMAIL" ]; then
        print_error "Email not configured. Run 'pauly config' first."
        exit 1
    fi

    print_info "Sending test email to $EMAIL..."

    if echo "This is a test email from your Pauly setup on $(hostname)." | mail -s "Pauly Test - $(date '+%Y-%m-%d %H:%M')" "$EMAIL" 2>/dev/null; then
        print_success "Test email sent to $EMAIL"
    else
        print_error "Failed to send email. Check your ~/.msmtprc configuration."
        exit 1
    fi
}

cmd_setup() {
    print_info "Running setup script..."
    echo "This requires sudo access."
    sudo "$SCRIPT_DIR/setup-mac-mini.sh"
}

cmd_config() {
    local subcommand="$1"

    case "$subcommand" in
        show|view)
            show_config
            ;;
        ""|set|edit)
            run_config_wizard
            ;;
        *)
            print_error "Unknown config command: $subcommand"
            echo "Usage: pauly config [show]"
            exit 1
            ;;
    esac
}

cmd_autofix() {
    local subcommand="${1:-status}"

    case "$subcommand" in
        status|"")
            autofix_status
            ;;
        test)
            autofix_test
            ;;
        logs|log)
            autofix_logs
            ;;
        *)
            print_error "Unknown autofix command: $subcommand"
            echo "Usage: pauly autofix [status|test|logs]"
            exit 1
            ;;
    esac
}

cmd_queue() {
    local subcommand="${1:-status}"

    case "$subcommand" in
        status|"")
            print_header
            echo -e "${BOLD}Task Queue Status:${NC}"
            echo ""

            if ! queue_enabled; then
                print_warning "Queue is disabled. Enable with QUEUE_ENABLED=true in config."
                return 0
            fi

            local stats=$(queue_status)
            local pending=$(echo "$stats" | jq -r '.pending // 0')
            local running=$(echo "$stats" | jq -r '.running // 0')
            local completed=$(echo "$stats" | jq -r '.completed // 0')
            local failed=$(echo "$stats" | jq -r '.failed // 0')

            echo -e "  ${YELLOW}●${NC} Pending:   $pending"
            echo -e "  ${BLUE}●${NC} Running:   $running"
            echo -e "  ${GREEN}●${NC} Completed: $completed"
            echo -e "  ${RED}●${NC} Failed:    $failed"

            local by_type=$(echo "$stats" | jq -r '.byTaskType // []')
            if [ "$by_type" != "[]" ]; then
                echo ""
                echo -e "${BOLD}Pending by type:${NC}"
                echo "$by_type" | jq -r '.[] | "  \(.task_type): \(.count)"'
            fi
            ;;
        list)
            if ! queue_enabled; then
                print_warning "Queue is disabled."
                return 0
            fi

            local status="${2:-}"
            local result=$(queue_list "$status" 20)
            echo "$result" | jq -r '.jobs[] | "[\(.id)] \(.status) - \(.task_type) (\(.created_at))"' 2>/dev/null || echo "No jobs found."
            ;;
        cleanup)
            if ! queue_enabled; then
                print_warning "Queue is disabled."
                return 0
            fi

            print_info "Cleaning up stale and old jobs..."
            local result=$(queue_cleanup 60 30)
            local stale=$(echo "$result" | jq -r '.staleReset // 0')
            local old=$(echo "$result" | jq -r '.oldDeleted // 0')
            print_success "Reset $stale stale jobs, deleted $old old jobs"
            ;;
        *)
            print_error "Unknown queue command: $subcommand"
            echo "Usage: pauly queue [status|list|cleanup]"
            exit 1
            ;;
    esac
}

cmd_completions() {
    local shell="${1:-}"

    case "$shell" in
        bash)
            echo "# Add this to your ~/.bashrc:"
            echo "source ~/.pauly/completions/pauly.bash"
            echo ""
            echo "# Or run this command to add it now:"
            echo "echo 'source ~/.pauly/completions/pauly.bash' >> ~/.bashrc && source ~/.bashrc"
            ;;
        zsh)
            echo "# Add this to your ~/.zshrc:"
            echo "source ~/.pauly/completions/pauly.zsh"
            echo ""
            echo "# Or run this command to add it now:"
            echo "echo 'source ~/.pauly/completions/pauly.zsh' >> ~/.zshrc && source ~/.zshrc"
            ;;
        "")
            # Auto-detect shell
            local current_shell=$(basename "$SHELL")
            if [ "$current_shell" = "zsh" ]; then
                cmd_completions "zsh"
            elif [ "$current_shell" = "bash" ]; then
                cmd_completions "bash"
            else
                echo "Completions available for: bash, zsh"
                echo ""
                echo "Usage: pauly completions <shell>"
                echo ""
                echo "Example:"
                echo "  pauly completions bash"
                echo "  pauly completions zsh"
            fi
            ;;
        *)
            print_error "Unknown shell: $shell"
            echo "Supported shells: bash, zsh"
            exit 1
            ;;
    esac
}

cmd_doctor() {
    print_header
    echo -e "${BOLD}System Health Check${NC}"
    echo ""

    local all_ok=true
    local warnings=0
    local errors=0

    # Helper functions for consistent output
    check_pass() { echo -e "  ${GREEN}✓${NC} $1"; }
    check_fail() { echo -e "  ${RED}✗${NC} $1"; ((errors++)); all_ok=false; }
    check_warn() { echo -e "  ${YELLOW}!${NC} $1"; ((warnings++)); }
    check_skip() { echo -e "  ${CYAN}○${NC} $1 (skipped)"; }

    # Section: Dependencies
    echo -e "${BOLD}Dependencies:${NC}"

    # Check Claude CLI
    if claude_path=$(check_cli "claude" "$HOME/.local/bin/claude" "/usr/local/bin/claude" "$HOME/.claude/local/claude"); then
        local claude_ver=$(claude --version 2>/dev/null | head -1 || echo "unknown")
        check_pass "claude CLI: $claude_ver"
    else
        check_fail "claude CLI not found - install from https://claude.ai/cli"
    fi

    # Check GitHub CLI
    if gh_path=$(check_cli "gh" "/opt/homebrew/bin/gh" "/usr/local/bin/gh"); then
        local gh_ver=$(gh --version 2>/dev/null | head -1 | awk '{print $3}' || echo "unknown")
        check_pass "gh CLI: v$gh_ver"
    else
        check_fail "gh CLI not found - install with: brew install gh"
    fi

    # Check Git
    if git_path=$(check_cli "git" "/opt/homebrew/bin/git" "/usr/local/bin/git"); then
        local git_ver=$(git --version 2>/dev/null | awk '{print $3}' || echo "unknown")
        check_pass "git: v$git_ver"
    else
        check_fail "git not found"
    fi

    # Check Node.js
    if node_path=$(check_cli "node" "/opt/homebrew/bin/node" "/usr/local/bin/node"); then
        local node_ver=$(node --version 2>/dev/null || echo "unknown")
        check_pass "node: $node_ver"
    else
        check_warn "node not found - needed for admin dashboard"
    fi

    # Check pnpm
    if pnpm_path=$(check_cli "pnpm" "/opt/homebrew/bin/pnpm" "/usr/local/bin/pnpm"); then
        local pnpm_ver=$(pnpm --version 2>/dev/null || echo "unknown")
        check_pass "pnpm: v$pnpm_ver"
    else
        check_warn "pnpm not found - run: npm install -g pnpm"
    fi

    # Check msmtp (for email)
    if msmtp_path=$(check_cli "msmtp" "/opt/homebrew/bin/msmtp" "/usr/local/bin/msmtp"); then
        check_pass "msmtp: installed"
    else
        check_warn "msmtp not found - needed for email alerts"
    fi

    # Check Railway CLI (optional)
    if railway_path=$(check_cli "railway" "/opt/homebrew/bin/railway" "/usr/local/bin/railway"); then
        local railway_ver=$(railway --version 2>/dev/null | head -1 || echo "unknown")
        check_pass "railway CLI: $railway_ver"
    else
        check_skip "railway CLI - optional for deployments"
    fi

    echo ""

    # Section: Configuration
    echo -e "${BOLD}Configuration:${NC}"

    if config_exists; then
        check_pass "Config file: $CONFIG_FILE"
    else
        check_fail "Config file not found - run: pauly config"
    fi

    if [ -n "$EMAIL" ]; then
        check_pass "Email: $EMAIL"
    else
        check_warn "Email not configured"
    fi

    if [ -n "$PROJECTS_DIR" ] && [ -d "$PROJECTS_DIR" ]; then
        local project_count=$(find "$PROJECTS_DIR" -maxdepth 1 -type d 2>/dev/null | wc -l | tr -d ' ')
        check_pass "Projects directory: $PROJECTS_DIR ($((project_count - 1)) projects)"
    else
        check_fail "Projects directory not found: ${PROJECTS_DIR:-not set}"
    fi

    if [ -n "$GITHUB_TASKS_REPO" ]; then
        check_pass "GitHub tasks repo: $GITHUB_TASKS_REPO"
    else
        check_skip "GitHub tasks repo - not configured"
    fi

    echo ""

    # Section: Authentication
    echo -e "${BOLD}Authentication:${NC}"

    if check_gh_auth 2>/dev/null; then
        local gh_user=$(gh api user --jq '.login' 2>/dev/null || echo "authenticated")
        check_pass "GitHub: logged in as $gh_user"
    else
        check_fail "GitHub: not authenticated - run: gh auth login"
    fi

    if command -v railway &> /dev/null; then
        if check_railway_auth 2>/dev/null; then
            local railway_user=$(railway whoami 2>/dev/null | head -1 || echo "authenticated")
            check_pass "Railway: $railway_user"
        else
            check_warn "Railway: not authenticated - run: railway login"
        fi
    fi

    echo ""

    # Section: Directories & Permissions
    echo -e "${BOLD}Directories:${NC}"

    if [ -d "$SCRIPT_DIR" ] && [ -w "$SCRIPT_DIR" ]; then
        check_pass "Pauly directory: $SCRIPT_DIR"
    else
        check_fail "Pauly directory not writable: $SCRIPT_DIR"
    fi

    if [ -d "$SCRIPT_DIR/logs" ] && [ -w "$SCRIPT_DIR/logs" ]; then
        local log_count=$(find "$SCRIPT_DIR/logs" -name "*.log" 2>/dev/null | wc -l | tr -d ' ')
        check_pass "Logs directory: $SCRIPT_DIR/logs ($log_count log files)"
    else
        check_warn "Logs directory not writable - creating..."
        mkdir -p "$SCRIPT_DIR/logs" 2>/dev/null && check_pass "Logs directory created" || check_fail "Could not create logs directory"
    fi

    echo ""

    # Section: Admin Dashboard
    echo -e "${BOLD}Admin Dashboard:${NC}"

    if [ -d "$SCRIPT_DIR/admin/server/dist" ]; then
        check_pass "Server build: ready"
    else
        check_warn "Server not built - run: cd $SCRIPT_DIR/admin && pnpm build"
    fi

    if [ -d "$SCRIPT_DIR/admin/client/dist" ]; then
        check_pass "Client build: ready"
    else
        check_warn "Client not built - run: cd $SCRIPT_DIR/admin && pnpm build"
    fi

    if [ -f "$SCRIPT_DIR/logs/admin.pid" ]; then
        local admin_pid=$(cat "$SCRIPT_DIR/logs/admin.pid")
        if kill -0 "$admin_pid" 2>/dev/null; then
            check_pass "Dashboard running: PID $admin_pid (http://localhost:${ADMIN_PORT:-3001})"
        else
            check_warn "Dashboard has stale PID file"
        fi
    else
        check_skip "Dashboard not running"
    fi

    echo ""

    # Summary
    echo -e "${BOLD}Summary:${NC}"
    if [ "$all_ok" = true ] && [ "$warnings" -eq 0 ]; then
        echo -e "  ${GREEN}All checks passed!${NC}"
    elif [ "$errors" -eq 0 ]; then
        echo -e "  ${YELLOW}$warnings warning(s), no errors${NC}"
    else
        echo -e "  ${RED}$errors error(s), $warnings warning(s)${NC}"
        echo ""
        echo "Fix the errors above to ensure Pauly works correctly."
    fi
}

cmd_admin() {
    local subcommand="${1:-start}"
    local admin_dir="$SCRIPT_DIR/admin"
    local pid_file="$SCRIPT_DIR/logs/admin.pid"
    local admin_log="$SCRIPT_DIR/logs/admin.log"

    case "$subcommand" in
        start|"")
            # Check if already running
            if [ -f "$pid_file" ]; then
                local old_pid=$(cat "$pid_file")
                if kill -0 "$old_pid" 2>/dev/null; then
                    print_warning "Admin dashboard is already running (PID: $old_pid)"
                    echo "View at: http://localhost:3001"
                    echo "Stop with: pauly admin stop"
                    return 0
                fi
            fi

            # Check if admin dashboard is built
            if [ ! -d "$admin_dir/server/dist" ]; then
                print_error "Admin dashboard not built. Run 'cd $admin_dir && pnpm build' first."
                exit 1
            fi

            print_info "Starting Pauly Admin Dashboard..."

            # Start the server in background (exec replaces subshell so PID file tracks node directly)
            (
                cd "$admin_dir/server"
                exec node dist/index.js >> "$admin_log" 2>&1
            ) &

            local server_pid=$!
            echo "$server_pid" > "$pid_file"
            disown "$server_pid"

            # Wait a moment for server to start
            sleep 1

            # Check if it started successfully
            if kill -0 "$server_pid" 2>/dev/null; then
                print_success "Admin dashboard started (PID: $server_pid)"
                echo ""
                echo "Dashboard: http://localhost:3001"
                echo "Stop with: pauly admin stop"
                echo "Logs: $admin_log"
            else
                print_error "Failed to start admin dashboard. Check $admin_log for errors."
                rm -f "$pid_file"
                exit 1
            fi
            ;;

        stop)
            if [ ! -f "$pid_file" ]; then
                # No PID file, but check if something is still on the port
                local orphan_pid=$(lsof -ti :${ADMIN_PORT:-3001} 2>/dev/null || true)
                if [ -n "$orphan_pid" ]; then
                    kill "$orphan_pid" 2>/dev/null
                    print_success "Admin dashboard stopped (orphaned process)"
                else
                    print_warning "Admin dashboard is not running"
                fi
                return 0
            fi

            local pid=$(cat "$pid_file")
            if kill -0 "$pid" 2>/dev/null; then
                kill "$pid"
                # Wait briefly for clean shutdown, then force kill if needed
                sleep 0.5
                if kill -0 "$pid" 2>/dev/null; then
                    kill -9 "$pid" 2>/dev/null
                fi
            fi
            # Also kill any orphan on the port (in case PID was stale subshell)
            local orphan_pid=$(lsof -ti :${ADMIN_PORT:-3001} 2>/dev/null || true)
            if [ -n "$orphan_pid" ]; then
                kill "$orphan_pid" 2>/dev/null
            fi
            rm -f "$pid_file"
            print_success "Admin dashboard stopped"
            ;;

        status)
            if [ -f "$pid_file" ]; then
                local pid=$(cat "$pid_file")
                if kill -0 "$pid" 2>/dev/null; then
                    print_success "Admin dashboard is running (PID: $pid)"
                    echo "Dashboard: http://localhost:3001"
                else
                    print_warning "Admin dashboard is not running (stale PID file)"
                fi
            else
                print_info "Admin dashboard is not running"
            fi
            ;;

        restart)
            cmd_admin stop
            sleep 1
            cmd_admin start
            ;;

        logs)
            if [ -f "$admin_log" ]; then
                tail -100 "$admin_log"
            else
                print_warning "No admin logs found"
            fi
            ;;

        *)
            print_error "Unknown admin command: $subcommand"
            echo "Usage: pauly admin [start|stop|status|restart|logs]"
            exit 1
            ;;
    esac
}

cmd_railway() {
    local subcommand="${1:-help}"

    # Check if railway CLI is installed
    if ! command -v railway &> /dev/null; then
        print_error "Railway CLI not installed"
        echo "Install with: bash <(curl -fsSL cli.new)"
        exit 1
    fi

    case "$subcommand" in
        deploy|up)
            shift
            print_info "Deploying to Railway..."
            railway up "$@"
            ;;

        link)
            shift
            print_info "Linking to Railway project..."
            railway link "$@"
            ;;

        status)
            print_info "Railway deployment status..."
            railway status
            ;;

        logs)
            shift
            print_info "Railway logs..."
            railway logs "$@"
            ;;

        env|vars|variables)
            shift
            local env_cmd="${1:-}"
            case "$env_cmd" in
                set)
                    shift
                    railway variables set "$@"
                    ;;
                unset|rm|remove)
                    shift
                    railway variables unset "$@"
                    ;;
                list|"")
                    railway variables
                    ;;
                *)
                    # Assume it's a set command: pauly railway env KEY=value
                    railway variables set "$env_cmd" "$@"
                    ;;
            esac
            ;;

        init)
            shift
            print_info "Initializing Railway project..."
            railway init "$@"
            ;;

        open)
            print_info "Opening Railway dashboard..."
            railway open
            ;;

        login)
            print_info "Logging in to Railway..."
            railway login
            ;;

        whoami)
            railway whoami
            ;;

        help|--help|-h|"")
            echo -e "${BOLD}Railway Commands:${NC}"
            echo ""
            echo "  pauly railway deploy       Deploy current directory to Railway"
            echo "  pauly railway link         Link to existing Railway project"
            echo "  pauly railway status       Check deployment status"
            echo "  pauly railway logs         View deployment logs"
            echo "  pauly railway env          List environment variables"
            echo "  pauly railway env set K=V  Set environment variable"
            echo "  pauly railway env unset K  Remove environment variable"
            echo "  pauly railway init         Initialize new Railway project"
            echo "  pauly railway open         Open project in browser"
            echo "  pauly railway login        Authenticate with Railway"
            echo "  pauly railway whoami       Show current Railway user"
            echo ""
            echo "For more options, use 'railway --help'"
            ;;

        *)
            # Pass through to railway CLI
            railway "$subcommand" "$@"
            ;;
    esac
}

cmd_dev() {
    ensure_claude_dev || exit 1

    local subcommand=""
    local dry_run=false
    local max_iter=0

    # Parse global dev flags first
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run)
                dry_run=true
                export DEV_DRY_RUN=true
                shift
                ;;
            -n)
                max_iter="$2"
                shift 2
                ;;
            -*)
                # Unknown flag, pass through
                break
                ;;
            *)
                subcommand="$1"
                shift
                break
                ;;
        esac
    done

    case "$subcommand" in
        init)
            local idea_file=""
            local template_name=""

            # Parse init arguments
            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --template|-t) template_name="$2"; shift 2 ;;
                    *) idea_file="$1"; shift ;;
                esac
            done

            # If template is "list", just list templates
            if [[ "$template_name" == "list" ]]; then
                source "$SCRIPT_DIR/lib/templates.sh" 2>/dev/null && list_templates
                exit 0
            fi

            # Need either idea file or template
            if [[ -z "$idea_file" && -z "$template_name" ]]; then
                print_error "Please specify an idea file or template"
                echo "Usage: pauly dev init <idea.md> [--template <name>]"
                echo "       pauly dev init --template <name>"
                echo "       pauly dev init --template list"
                exit 1
            fi
            if [[ "$dry_run" = true ]]; then
                print_info "[DRY-RUN] Would initialize project"
                if [[ -n "$template_name" ]]; then
                    echo "  Template: $template_name"
                fi
                if [[ -n "$idea_file" && -f "$idea_file" ]]; then
                    echo "  Idea file: $idea_file"
                    echo ""
                    echo "Idea file contents:"
                    head -20 "$idea_file"
                fi
                exit 0
            fi
            dev_init "$idea_file" "$template_name"
            ;;

        refresh)
            local notes_file="${1:-notes.md}"
            if [[ "$dry_run" = true ]]; then
                print_info "[DRY-RUN] Would refresh tasks from: $notes_file"
                exit 0
            fi
            dev_refresh "$notes_file"
            ;;

        task)
            local task_desc=""
            local branch_name=""
            local no_pr=false
            local task_file=""

            while [[ $# -gt 0 ]]; do
                case "$1" in
                    --branch) branch_name="$2"; shift 2 ;;
                    --no-pr) no_pr=true; shift ;;
                    -n) max_iter="$2"; shift 2 ;;
                    -f|--file) task_file="$2"; shift 2 ;;
                    *) task_desc="$1"; shift ;;
                esac
            done

            if [[ "$dry_run" = true ]]; then
                print_info "[DRY-RUN] Would run task mode:"
                echo "  Task: ${task_desc:-<from file>}"
                echo "  Branch: ${branch_name:-<auto>}"
                echo "  Max iterations: $([[ "$max_iter" -eq 0 ]] && echo "unlimited" || echo "$max_iter")"
                echo "  Create PR: $([[ "$no_pr" = true ]] && echo "no" || echo "yes")"
                exit 0
            fi
            dev_task "$task_desc" "$branch_name" "$no_pr" "$max_iter" "$task_file"
            ;;

        status|st)
            dev_status
            ;;

        ""|[0-9]*)
            # Default: run main loop
            if [[ -n "$subcommand" ]] && [[ "$subcommand" =~ ^[0-9]+$ ]]; then
                max_iter="$subcommand"
            fi
            dev_loop "$max_iter"
            ;;

        *)
            # Check if it's a number passed with other args
            if [[ "$subcommand" =~ ^[0-9]+$ ]]; then
                dev_loop "$subcommand"
            else
                print_error "Unknown dev command: $subcommand"
                echo "Run 'pauly dev help' or 'pauly help' for usage"
                exit 1
            fi
            ;;
    esac
}

cmd_kill() {
    print_header
    echo -e "${BOLD}${RED}KILLSWITCH${NC} - Stopping all Claude processes..."
    echo ""

    # Find all Claude CLI processes
    local claude_pids=$(pgrep -f "claude" 2>/dev/null || true)

    # Find all pauly dev processes
    local dev_pids=$(pgrep -f "pauly dev" 2>/dev/null || true)

    # Combine and deduplicate
    local all_pids=$(echo -e "$claude_pids\n$dev_pids" | sort -u | grep -v "^$" || true)

    if [ -z "$all_pids" ]; then
        print_info "No Claude or Pauly dev processes running"
        return 0
    fi

    local count=$(echo "$all_pids" | wc -l | tr -d ' ')
    echo "Found $count process(es) to terminate:"
    echo ""

    # Show what we're killing
    for pid in $all_pids; do
        local cmd=$(ps -p "$pid" -o command= 2>/dev/null | head -c 80 || echo "unknown")
        echo "  PID $pid: $cmd"
    done
    echo ""

    # Kill them all
    local killed=0
    for pid in $all_pids; do
        if kill -TERM "$pid" 2>/dev/null; then
            ((killed++))
        fi
    done

    # Wait a moment for graceful shutdown
    sleep 1

    # Force kill any remaining
    for pid in $all_pids; do
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" 2>/dev/null && print_warning "Force killed PID $pid"
        fi
    done

    print_success "Terminated $killed process(es)"

    # Also clear any dev logs to reset state
    echo ""
    print_info "Clearing dev status logs..."
    rm -f "$SCRIPT_DIR/logs/dev-"*.log 2>/dev/null || true
    print_success "Dev logs cleared"
}

cmd_install() {
    print_header
    echo -e "${BOLD}Installing dependencies...${NC}"
    echo ""

    local failed=0

    # Detect package manager
    local pm="npm"
    if command -v pnpm &> /dev/null; then
        pm="pnpm"
    elif command -v yarn &> /dev/null; then
        pm="yarn"
    fi

    print_info "Using package manager: $pm"
    echo ""

    # Admin server
    if [ -d "$SCRIPT_DIR/admin/server" ]; then
        echo -e "${BOLD}[1/3] Admin Server${NC}"
        if (cd "$SCRIPT_DIR/admin/server" && $pm install); then
            print_success "Server dependencies installed"
        else
            print_error "Failed to install server dependencies"
            ((failed++))
        fi
        echo ""
    fi

    # Admin client
    if [ -d "$SCRIPT_DIR/admin/client" ]; then
        echo -e "${BOLD}[2/3] Admin Client${NC}"
        if (cd "$SCRIPT_DIR/admin/client" && $pm install); then
            print_success "Client dependencies installed"
        else
            print_error "Failed to install client dependencies"
            ((failed++))
        fi
        echo ""
    fi

    # Queue module
    if [ -d "$SCRIPT_DIR/queue" ]; then
        echo -e "${BOLD}[3/3] Queue Module${NC}"
        if (cd "$SCRIPT_DIR/queue" && npm install); then
            print_success "Queue dependencies installed"
        else
            print_error "Failed to install queue dependencies"
            ((failed++))
        fi
        echo ""
    fi

    if [ $failed -eq 0 ]; then
        print_success "All dependencies installed successfully!"
        echo ""
        echo "Next steps:"
        echo "  pauly admin start   # Start the admin dashboard"
        echo "  pauly doctor        # Check system health"
    else
        print_error "$failed package(s) failed to install"
        return 1
    fi
}

# ==========================================
# Main
# ==========================================

case "${1:-tui}" in
    run)
        cmd_run "$2" "$3"
        ;;
    dev)
        shift
        cmd_dev "$@"
        ;;
    admin)
        cmd_admin "$2"
        ;;
    railway)
        shift
        cmd_railway "$@"
        ;;
    status|st)
        cmd_status
        ;;
    logs|log)
        shift
        cmd_logs "$@"
        ;;
    tail|follow)
        cmd_tail "$2"
        ;;
    enable)
        cmd_enable "$2"
        ;;
    disable)
        cmd_disable "$2"
        ;;
    test-email|test)
        cmd_test_email
        ;;
    setup)
        cmd_setup
        ;;
    install)
        cmd_install
        ;;
    config|configure)
        cmd_config "$2"
        ;;
    autofix|auto-fix)
        cmd_autofix "$2"
        ;;
    queue)
        cmd_queue "$2"
        ;;
    tui)
        if [ -d "$SCRIPT_DIR/tui/dist" ]; then
            exec node "$SCRIPT_DIR/tui/dist/index.js"
        elif command -v tsx &> /dev/null; then
            exec tsx "$SCRIPT_DIR/tui/src/index.tsx"
        else
            print_error "TUI not built. Run: cd ~/.pauly/tui && pnpm install && pnpm build"
            exit 1
        fi
        ;;
    doctor|health|check)
        cmd_doctor
        ;;
    completions|completion)
        cmd_completions "$2"
        ;;
    kill|killswitch|stop-all)
        cmd_kill
        ;;
    version|--version|-v)
        cmd_version "$2"
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        print_error "Unknown command: $1"
        echo "Run 'pauly help' for usage."
        exit 1
        ;;
esac
